---
name: github-workflow
description: Clone GitHub repositories, create feature branches, commit changes, and push to remote. Use when working with GitHub repos that need to be cloned locally, branched, and updated.
allowed-tools: Bash, Read, Write, Glob, Grep
---

# GitHub Workflow Skill

Manage GitHub repository operations for migration workflows including cloning, branching, committing, and pushing.

## Prerequisites

- GitHub CLI (`gh`) must be installed and authenticated
- Git must be configured with user credentials
- SSH or HTTPS access to target repositories

## Operations

### Clone Repository

Clone a GitHub repository to a local workspace:

```bash
# Clone to workspace
gh repo clone owner/repo /path/to/workspace/repo

# Or with git directly
git clone https://github.com/owner/repo.git /path/to/workspace/repo
```

### Batch Clone Multiple Repos

```bash
# Clone multiple repos in parallel
for repo in repo1 repo2 repo3; do
  gh repo clone owner/$repo /path/to/workspace/$repo &
done
wait
```

### Create Feature Branch

Create a standardized feature branch for migration work with branch reuse support:

```bash
cd /path/to/repo

BRANCH="feature/spring-boot-4-migration"

# Check if migration branch exists locally
if git show-ref --verify --quiet "refs/heads/$BRANCH"; then
  echo "Local branch '$BRANCH' exists, checking out..."
  git checkout "$BRANCH"

  # Optionally pull latest from remote if it exists
  if git ls-remote --heads origin "$BRANCH" | grep -q .; then
    echo "Pulling latest changes from remote..."
    git pull origin "$BRANCH" --rebase
  fi

# Check if migration branch exists on remote only
elif git ls-remote --heads origin "$BRANCH" | grep -q .; then
  echo "Remote branch '$BRANCH' exists, fetching and checking out..."
  git fetch origin "$BRANCH"
  git checkout -b "$BRANCH" "origin/$BRANCH"

# No existing branch - create new
else
  echo "Creating new migration branch '$BRANCH'..."
  git checkout -b "$BRANCH"

  # Initialize migration state file
  MIGRATION_ID="sb4-$(date +%Y%m%d)-$(uuidgen | head -c 8)"
  TIMESTAMP="$(date -u +%Y-%m-%dT%H:%M:%SZ)"

  cat > .migration-state.yaml << EOF
migrationId: $MIGRATION_ID
branch: $BRANCH
startedAt: $TIMESTAMP
lastUpdatedAt: $TIMESTAMP
marketplaceVersion: "1.0.0"  # Update with actual version
targetVersions:
  spring-boot: "4.0.0"
  jackson: "3.0.0"
  spring-security: "7.0.0"
appliedTransformations: []
pendingTransformations: []
validationStatus: NOT_RUN
validationDetails: {}
lastError: null
EOF

  echo "Initialized .migration-state.yaml"
  git add .migration-state.yaml
  git commit -m "chore: initialize migration state

Migration ID: $MIGRATION_ID
Branch: $BRANCH

Generated by Spring Modernization Marketplace"
fi
```

**Branch Naming Convention:**

- `feature/spring-boot-4-migration` - Main migration branch
- `feature/sb4-jackson-upgrade` - Jackson-specific changes
- `feature/sb4-security-upgrade` - Security-specific changes

**Branch Reuse Strategy:**

- **Existing local branch**: Checkout and optionally pull from remote
- **Remote branch only**: Fetch and checkout from origin
- **No existing branch**: Create new branch and initialize `.migration-state.yaml`
- **State file**: Branch-specific, committed to migration branch, gitignored from main

### Commit Changes

Stage and commit migration changes with descriptive messages:

```bash
cd /path/to/repo

# Stage all changes
git add -A

# Commit with migration-specific message
git commit -m "chore: migrate to Spring Boot 4.x

- Update Spring Boot parent to 4.0.0
- Migrate Jackson 2.x to 3.x (groupId: tools.jackson)
- Update Spring Security 6 to 7 patterns
- Update Spring Cloud BOM to 2025.1.0

Generated by Spring Modernization Marketplace"
```

### Push Branch

Push the feature branch to remote:

```bash
cd /path/to/repo
git push -u origin feature/spring-boot-4-migration
```

## Migration State Management

### State File Structure

The `.migration-state.yaml` file tracks migration progress and enables idempotent operations:

```yaml
migrationId: sb4-20260103-a1b2c3d4
branch: feature/spring-boot-4-migration
startedAt: '2026-01-03T10:30:00Z'
lastUpdatedAt: '2026-01-03T11:45:00Z'
marketplaceVersion: '1.0.0'
targetVersions:
  spring-boot: '4.0.0'
  jackson: '3.0.0'
  spring-security: '7.0.0'
appliedTransformations:
  - skill: jackson-migrator
    version: '1.0.0'
    transformations:
      - jackson-imports
      - jackson-groupid
    completedAt: '2026-01-03T10:35:00Z'
    commitSha: abc123
  - skill: spring-security-migrator
    version: '1.0.0'
    transformations:
      - security-config
      - authorizations
    completedAt: '2026-01-03T10:42:00Z'
    commitSha: def456
pendingTransformations:
  - spring-ai-migrator
validationStatus: FAILED
validationDetails:
  compile:
    success: false
    errors: 3
  tests:
    skipped: true
lastError: '3 compilation errors in SecurityConfig.java'
```

### State File Lifecycle

1. **Initialization**: Created when new migration branch is created
2. **Updates**: Modified by migration skills after each transformation
3. **Persistence**: Committed to the migration branch (not main)
4. **Cleanup**: Retained on branch for audit trail and resume capability

### State File Location

- **Migration branch**: Committed and tracked
- **Main branch**: Gitignored via `.gitignore` entry
- **Branch-specific**: Each migration branch has its own state file

### Gitignore Configuration

Add to main branch `.gitignore`:

```gitignore
# Migration state files (only committed on migration branches)
.migration-state.yaml
```

## Workflow Integration

### Full Clone-to-Push Workflow

```bash
# 1. Clone
gh repo clone owner/repo /workspace/repo
cd /workspace/repo

# 2. Create or reuse branch with state initialization
BRANCH="feature/spring-boot-4-migration"

if git show-ref --verify --quiet "refs/heads/$BRANCH"; then
  # Reuse local branch
  git checkout "$BRANCH"
  if git ls-remote --heads origin "$BRANCH" | grep -q .; then
    git pull origin "$BRANCH" --rebase
  fi
elif git ls-remote --heads origin "$BRANCH" | grep -q .; then
  # Reuse remote branch
  git fetch origin "$BRANCH"
  git checkout -b "$BRANCH" "origin/$BRANCH"
else
  # Create new branch and initialize state
  git checkout -b "$BRANCH"

  # Initialize state file
  MIGRATION_ID="sb4-$(date +%Y%m%d)-$(uuidgen | head -c 8)"
  cat > .migration-state.yaml << EOF
migrationId: $MIGRATION_ID
branch: $BRANCH
startedAt: $(date -u +%Y-%m-%dT%H:%M:%SZ)
lastUpdatedAt: $(date -u +%Y-%m-%dT%H:%M:%SZ)
marketplaceVersion: "1.0.0"
targetVersions:
  spring-boot: "4.0.0"
  jackson: "3.0.0"
  spring-security: "7.0.0"
appliedTransformations: []
pendingTransformations: []
validationStatus: NOT_RUN
EOF

  git add .migration-state.yaml
  git commit -m "chore: initialize migration state"
fi

# 3. [Migration happens here via other skills]

# 4. Stage and commit
git add -A
git commit -m "chore: migrate to Spring Boot 4.x

<migration details>"

# 5. Push
git push -u origin feature/spring-boot-4-migration
```

### Parallel Clone Pattern

For migrating multiple repos efficiently:

```bash
WORKSPACE="/tmp/migration-workspace"
REPOS=("owner/repo1" "owner/repo2" "owner/repo3")

# Parallel clone
for repo in "${REPOS[@]}"; do
  name=$(basename $repo)
  gh repo clone $repo "$WORKSPACE/$name" &
done
wait

echo "All repos cloned to $WORKSPACE"
```

## Permission Detection

Before pushing changes, detect if the user has write access to determine if a fork-based workflow is required.

### Check Repository Permissions

```bash
# Get user's permission level on a repository
PERMISSION=$(gh repo view owner/repo --json viewerPermission --jq ".viewerPermission")
echo "Permission: $PERMISSION"

# Possible values: ADMIN, MAINTAIN, WRITE, READ, or null/empty
```

| Permission   | Can Push Directly | Notes                   |
| ------------ | ----------------- | ----------------------- |
| `ADMIN`      | Yes               | Full access             |
| `MAINTAIN`   | Yes               | Can push, manage issues |
| `WRITE`      | Yes               | Standard contributor    |
| `READ`       | No                | Fork required           |
| `null/empty` | No                | Fork required           |

### Check If User Is Repo Owner

```bash
# Get authenticated user
CURRENT_USER=$(gh api user --jq ".login")

# Get repo owner
REPO_OWNER=$(gh repo view owner/repo --json owner --jq ".owner.login")

# Compare
if [ "$CURRENT_USER" = "$REPO_OWNER" ]; then
  echo "User is repo owner - direct push allowed"
else
  echo "User is not owner - check permissions"
fi
```

### Comprehensive Permission Check Function

```bash
# Check if user can push directly to a repository
can_push_directly() {
  local REPO="$1"  # owner/repo format

  # Get permission level
  PERMISSION=$(gh repo view "$REPO" --json viewerPermission --jq ".viewerPermission" 2>/dev/null)

  case "$PERMISSION" in
    ADMIN|MAINTAIN|WRITE)
      return 0  # Can push directly
      ;;
    *)
      return 1  # Fork required
      ;;
  esac
}

# Usage
if can_push_directly "owner/repo"; then
  echo "Direct push available"
  git push -u origin feature/spring-boot-4-migration
else
  echo "Fork-based workflow required"
  # See Fork-Based Workflow section below
fi
```

## Fork-Based Workflow

When the user lacks push access to the target repository, use a fork-based workflow.

### Detect Existing Fork

```bash
UPSTREAM_REPO="owner/repo"
CURRENT_USER=$(gh api user --jq ".login")

# Check if fork already exists
FORK_EXISTS=$(gh repo view "$CURRENT_USER/$(basename $UPSTREAM_REPO)" --json name 2>/dev/null && echo "yes" || echo "no")

if [ "$FORK_EXISTS" = "yes" ]; then
  echo "Fork already exists: $CURRENT_USER/$(basename $UPSTREAM_REPO)"
else
  echo "No fork found - will need to create one"
fi
```

### Create Fork If Needed

```bash
UPSTREAM_REPO="owner/repo"

# Create fork (--clone=false since we already have the repo cloned)
gh repo fork "$UPSTREAM_REPO" --clone=false

# Get the fork URL
CURRENT_USER=$(gh api user --jq ".login")
FORK_REPO="$CURRENT_USER/$(basename $UPSTREAM_REPO)"
echo "Fork created: $FORK_REPO"
```

### Configure Fork Remote

```bash
cd /path/to/cloned/repo

CURRENT_USER=$(gh api user --jq ".login")
REPO_NAME=$(basename $(pwd))

# Add fork as a remote
git remote add fork "https://github.com/$CURRENT_USER/$REPO_NAME.git"

# Verify remotes
git remote -v
# origin  https://github.com/owner/repo.git (fetch)
# origin  https://github.com/owner/repo.git (push)
# fork    https://github.com/current-user/repo.git (fetch)
# fork    https://github.com/current-user/repo.git (push)
```

### Push to Fork

```bash
# Push feature branch to fork instead of origin
git push -u fork feature/spring-boot-4-migration
```

### Full Fork-Based Workflow

Complete workflow for repos without push access with branch reuse support:

```bash
UPSTREAM_REPO="owner/repo"
BRANCH_NAME="feature/spring-boot-4-migration"
WORKSPACE="/tmp/migration-workspace"

# 1. Clone upstream repo
REPO_NAME=$(basename "$UPSTREAM_REPO")
gh repo clone "$UPSTREAM_REPO" "$WORKSPACE/$REPO_NAME"
cd "$WORKSPACE/$REPO_NAME"

# 2. Check permissions
PERMISSION=$(gh repo view "$UPSTREAM_REPO" --json viewerPermission --jq ".viewerPermission")

if [[ "$PERMISSION" =~ ^(ADMIN|MAINTAIN|WRITE)$ ]]; then
  # Direct push workflow with branch reuse
  if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
    git checkout "$BRANCH_NAME"
    if git ls-remote --heads origin "$BRANCH_NAME" | grep -q .; then
      git pull origin "$BRANCH_NAME" --rebase
    fi
  elif git ls-remote --heads origin "$BRANCH_NAME" | grep -q .; then
    git fetch origin "$BRANCH_NAME"
    git checkout -b "$BRANCH_NAME" "origin/$BRANCH_NAME"
  else
    git checkout -b "$BRANCH_NAME"

    # Initialize state file
    MIGRATION_ID="sb4-$(date +%Y%m%d)-$(uuidgen | head -c 8)"
    cat > .migration-state.yaml << EOF
migrationId: $MIGRATION_ID
branch: $BRANCH_NAME
startedAt: $(date -u +%Y-%m-%dT%H:%M:%SZ)
lastUpdatedAt: $(date -u +%Y-%m-%dT%H:%M:%SZ)
marketplaceVersion: "1.0.0"
targetVersions:
  spring-boot: "4.0.0"
  jackson: "3.0.0"
  spring-security: "7.0.0"
appliedTransformations: []
pendingTransformations: []
validationStatus: NOT_RUN
EOF
    git add .migration-state.yaml
    git commit -m "chore: initialize migration state"
  fi

  # ... make changes ...
  git add -A && git commit -m "chore: migrate to Spring Boot 4.x"
  git push -u origin "$BRANCH_NAME"
  gh pr create --title "chore: Migrate to Spring Boot 4.x" --body "$PR_BODY"
else
  # Fork-based workflow with branch reuse
  CURRENT_USER=$(gh api user --jq ".login")

  # Create fork if needed
  gh repo fork "$UPSTREAM_REPO" --clone=false 2>/dev/null || true

  # Add fork remote
  git remote add fork "https://github.com/$CURRENT_USER/$REPO_NAME.git" 2>/dev/null || true

  # Check for existing branch in fork
  if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
    git checkout "$BRANCH_NAME"
    if git ls-remote --heads fork "$BRANCH_NAME" | grep -q .; then
      git pull fork "$BRANCH_NAME" --rebase
    fi
  elif git ls-remote --heads fork "$BRANCH_NAME" | grep -q .; then
    git fetch fork "$BRANCH_NAME"
    git checkout -b "$BRANCH_NAME" "fork/$BRANCH_NAME"
  else
    git checkout -b "$BRANCH_NAME"

    # Initialize state file
    MIGRATION_ID="sb4-$(date +%Y%m%d)-$(uuidgen | head -c 8)"
    cat > .migration-state.yaml << EOF
migrationId: $MIGRATION_ID
branch: $BRANCH_NAME
startedAt: $(date -u +%Y-%m-%dT%H:%M:%SZ)
lastUpdatedAt: $(date -u +%Y-%m-%dT%H:%M:%SZ)
marketplaceVersion: "1.0.0"
targetVersions:
  spring-boot: "4.0.0"
  jackson: "3.0.0"
  spring-security: "7.0.0"
appliedTransformations: []
pendingTransformations: []
validationStatus: NOT_RUN
EOF
    git add .migration-state.yaml
    git commit -m "chore: initialize migration state"
  fi

  # ... make changes ...
  git add -A && git commit -m "chore: migrate to Spring Boot 4.x"

  # Push to fork
  git push -u fork "$BRANCH_NAME"

  # Create PR from fork to upstream
  gh pr create \
    --repo "$UPSTREAM_REPO" \
    --head "$CURRENT_USER:$BRANCH_NAME" \
    --title "chore: Migrate to Spring Boot 4.x" \
    --body "$PR_BODY"
fi
```

## Output Format (with Fork Info)

Report repository status including fork information:

```json
{
  "repo": "owner/repo",
  "status": "cloned",
  "localPath": "/workspace/repo",
  "branch": "feature/spring-boot-4-migration",
  "remote": "origin",
  "permissions": {
    "level": "READ",
    "canPushDirectly": false
  },
  "fork": {
    "required": true,
    "exists": true,
    "url": "https://github.com/current-user/repo",
    "remote": "fork"
  }
}
```

## Error Handling

### Clone Failures

```bash
# Check if repo exists and is accessible
gh repo view owner/repo --json name

# Handle authentication issues
gh auth status
gh auth login
```

### Push Failures

```bash
# Check remote status
git remote -v

# Verify branch doesn't exist
git ls-remote --heads origin feature/spring-boot-4-migration

# Force push if needed (with caution)
git push -u origin feature/spring-boot-4-migration --force-with-lease
```

### Branch Already Exists

```bash
# Reuse existing branch (DO NOT delete and recreate)
BRANCH="feature/spring-boot-4-migration"

if git show-ref --verify --quiet "refs/heads/$BRANCH"; then
  echo "Branch exists locally, checking out..."
  git checkout "$BRANCH"

  # Pull latest if remote exists
  if git ls-remote --heads origin "$BRANCH" | grep -q .; then
    git pull origin "$BRANCH" --rebase
  fi
elif git ls-remote --heads origin "$BRANCH" | grep -q .; then
  echo "Branch exists on remote, checking out..."
  git fetch origin "$BRANCH"
  git checkout -b "$BRANCH" "origin/$BRANCH"
fi
```

## Output Format

Report repository status:

```json
{
  "repo": "owner/repo",
  "status": "cloned",
  "localPath": "/workspace/repo",
  "branch": "feature/spring-boot-4-migration",
  "remote": "origin"
}
```

## Critical Rules

1. **Always verify authentication** before cloning private repos
2. **Check permissions before pushing** - use fork-based workflow if READ-only access
3. **Create backup branches** before making changes
4. **Use descriptive commit messages** that explain migration changes
5. **Never force push to main/master** branches
6. **Reuse existing migration branches** - DO NOT delete and recreate branches
7. **Initialize state file on new branches** - Create `.migration-state.yaml` when creating new migration branch
8. **State file is branch-specific** - Each migration branch has its own state tracking
9. **For cross-org repos** - assume fork workflow needed unless permissions confirm otherwise
